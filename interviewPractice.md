## 모의 면접 준비

1. 부트캠프를 들은 것 같은데, 개발을 배우게 된 자신만의 배경 및 스토리

   - 저는 원래 제 일을 차려서 하고 싶은 사람이었습니다. 그렇다보니 자연스레 여러가지 웹 기반 서비스를 생각하게 되었습니다. 서비스를 구현하는데 어떤 방법이 가장 빠를까 생각을 하다가 제 손으로 구현하는 방법이 빠를 것 같은 생각이 들어서 처음으로 개발을 시작해보았습니다. 막상 개발을 시작해보니 노트북하나로 새로움을 창조할 수 있다는 매력에 빠졌습니다. 지금은 개발을 가장 좋아하는 사람입니다.

2. 회사에 지원한 이유

   - 청년들의 취업문제를 같이 겪고 있는 사람으로서 그리고 학창시절에 왜 공부를 해야하는지 모르던 사람으로서 오픈놀이 해결책이 될 수 있다는 생각을 해서 이 곳에서 일해보고 싶다는 생각에 지원하게 되었습니다.

3. 회사에 궁금한점?

   - 어떤 조직 문화를 갖고 있는지
   - 개발팀은 어떤식으로 일하고 커뮤니케이션하는지
   - 개발자로서 성장할 수 있는 개발팀 문화가 있다면 어떤 게 있는지
   - 현재 진행하고 있는 프로젝트와 다음 프로젝트는 무엇인지
   - 홈페이지를 통해 봤습니다만 면접관님을 통해 OOO이 어떤 회사인지 간략한 소개를 들어보고 싶습니다.
   - 고객이 원하는 제품을 만들기 위해 어떻게 노력하는지
   - 마지막으로 면접 다음에는 어떻게 진행이 되는지 궁금합니다.
   
4. closure에 대해 설명하고 예를 이야기해라

   - 어떤 함수가 선언될 때 선언된 환경을 기억하는 것이다. 예를 들어보자면 

     function outer(){

     ​	var some = 1;

     ​	return function(){

     ​		alert(some);

     ​	} 

     }

   이런 상황에서 let a = outer();를 하고 a를 실행하면 값이 안나올 것 같지만, 클로저는 선언된 환경을 기억하기 때문에 alert이 실행된다.

   

   번외: lexical scoping이란: 스코프는 함수를 **선언**할 때 생긴다. 그래서 선언된 이후 무슨짓을 하더라도 선언된 함수가 참조하고 있는 값을 다른 값으로 바꾸는 수는 없다. 

   함수 호출 시 마다 context가 생깁니다.

   context 생성 시 그 안에 arguments, variable, scope chain, this가 생성된다.

   함수 실행이 마무리되면 해당 context는 사라집니다. 

5. js에서 this란 무엇이고 어디에 사용되나요

   - this는 객체를 가리키는 keyword이다. 기본적으론 window를 가리키지만 특정 상황에선 특정 object를 가리킨다. 객체가 선언될 때 그 객체를 가리키는 어떤 행위를 하고 싶을 때 사용한다. 예로는

     let person = {

     ​	name: 'gun',

     ​	greeting: function(){

     ​		return 'hi' + this.name 

     ​	}

     }

     이런 경우가 있다.

6. nodejs가 무엇이고 어디에 사용하나?

   - 노드는 자바스크립트 런타임 환경이다.
   - v8엔진은 javascript code를 machine code로 바꿔준다.
   - 런타임: 프로그래밍 언어가 구동되고 있는 환경
   - 자바스크립트 런타임: 웹브라우저, node js
   - node js는 v8에서 구동되는 자바스크립트 런타임이다. server side platform

7. javascript와 node의 차이점

   - node js의 개념을 먼저 설명하면 javascript 런타임 중에 하나로 javascript언어로 된 구동환경 중 하나이다. 따라서 javascript가 더 넓은 개념이고 이 코드가 구동되는 런타임중 하나가 node js라 할 수 있다.

8. deep & shallow object copy

   - deep 은 어떤 object를 완전히 copy하는데 참조하는 주소값이 다르다. 따라서 원본이 바뀌더라도 바뀌지 않고 Object.assign을 사용하는 방법이 있다.
   - shallow copy는 같은 주소값을 참조하는 것으로 원본이 바뀌면 copy 값도 바뀐다.

9. 모든 자바스크립트 파일을 브라우저에서 한번에 로딩할 때 문제점

   - 브라우저에서 파일을 띄울 땐 html을 사용해서 보여주는데 이때 javascript 파일이 외부에 있어서 script tag로 참조하면 외부에서 가져오는 시간과 파싱, 실행시간까지 포함해서 기다려야 하므로 사용자 경험이 떨어질 수 있다.
   - 그래서 해결방법은 스크립트 태그를 밑에 넣어서 주요내용들이 다보인후 스크립트를 로딩하고 처리하는 것이 사용자 경험을 높여준다.

10. promise에 대해 설명

    - 비동기적 처리의 최종 성공 값 또는 실패이유를 핸들러할 수 있는 keyword로 callback 대신 많이 사용하고 비동기 과정을 동기 과정처럼 반환할 수 있고 promise를 반환한다.

11. oop의 4가지 특징과 사용해본 경험

    - 추상화, 캡슐화, 상속성, 다형성 

    - 아우디, 벤츠를 차라는 개념으로 단순화 시켜생각하는 것

    - 변경될 가능성이 큰 것은 외부에서 접근하지 못하도록 private하게 관리하는 것

    - Class의 속성을 상속해주어 재사용성을 높이는 것

    - 상위클래스에게 상속 받은 동일한 메소드를 재정의하거나, 동일한 메소드가 매개변수에 따라 다르게 동작하는 것을 말한다?

      코드스테이츠에서 sprint를 진행할 때 여러 종류의 벌들이 만들어지는 것을 코드로 표현해본적이 있다. 그때 애벌레, 일벌, 은퇴한 벌등 여러가지에 벌에 따라 서로의 속성을 상속해주는 과정이 있었다.

12. var 와 let 의 차이

    - block scope와 function scope의 차이도 있지만 var만 호이스팅이 적용된다. const 와 let은 안됌

13. 크롬 브라우저 외 es6를 지원 안하는 브라우저의 경우 개발자로서 해결 방법은? 

    - babel이라는 transpiler를 사용하여 상위버전의 ecmascript를 하위 버전의 에크마로 바꿀 수 있다.

14. 타입 스크립트란? 경험은?

    - 타입스크립트는 자바스크립트를 기반으로 모든 변수의 타입을 지정해 줌으로써 코드의 유지 보수를 높일 수 있다

15. nodejs가 싱글스레드인 이유

    - javascript를 기반으로 하는데 구동되는 환경만 다른것이지 기반 언어가 같으므로 싱글스레드이다.

16. express는 무엇인가 역할은?
    - node js에서 동작하는 웹개발 프레임워크, http모듈과 connect 컴포넌트를 기반으로 함
    - 그러한 컴포넌트를 미들웨어라고 한다.
- http 요청에 대한 핸들링을 도와준다.
  
17. nodejs에서 event loop란?

    - 작업을 완료 여부를 신경쓰지 않고 넘겨서 논 블로킹 I/O 작업을 수행하도록 해준다.

18. package.json의 역할은?

    - npm 에서 핵심적인 역할을 하는 패키지의 정보와 의존중인 버전에 대한 정보를 담고 있는 곳,
    - scripts는 npm 명령어, dependencies는 사용중인 패키지들의 버전들 devDependencies는 개발 모드일때만, peer는 직접 require은 하지 않지만 호환되는 패키지 목록

19. nodejs에서 callback 설명

    - 비동기함수에서 흐름을 끊지 않고 어떤값을 처리할 때 쓰는 방식

20. 다른 개발환경이 아닌 nodejs의 장점은?

    - 논블로킹이라 막히지 않고 시간이 걸리면 넘겨서 처리가 끝난 뒤 받아서 처리하기 때문에 빠르다!

21. 54321배열은 12345로 정렬할 때 어떤 sort를 쓰겠는가? 왜??

    - 버블 소트: 인접한 두개 비교해서 자리교환
    - 셀렉션 소트: 가장 작은 거 찾아서 첫번째와 바꾸고, 그 다음 작은 거 두번째와 바꾸고
    - 인설션 소트: 두개의 부분집합으로 정렬된 한개의 부분집합에 다른 부분집합 원소를 하나씩 꺼내서 정렬된 것에 집어넣는다.
    - 퀵소트: 기준값을 중심으로 크고 작음에 따라 왼쪽 또는 오른쪽으로 정렬
    - 힙소트: 최대힙은 부노드가 자노드보다 큰 트리로 단말노드를 자노드로 가진 부노드로부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다. 가장 큰수를 가장 작은 수와 교환한다.
    - 머지소트: 자료를 같은 크기의 부분집합 2개로 분할, 부분집합의 크기가 충분히 작지 않으면 다시 분할, 정렬된 부분집합들을 하나의 집합으로 결합, 완성
    - 라딕스 소트: 일의자리로 0-9까지 큐에 한번 넣고, 꺼내서 다시 십의자리로 0-9까지 큐에 넣고 가장큰숫자가 있는 자릿수까지 (123이 가장크면 100의자리까지) 세어서 큐에 넣으면 정렬할 수 있다.

22. insertion sort가 일어나는 과정 설명

    - 위 참고

23. quick sort 과정 설명

    - 위참고

24. DFS vs BFS ?

    - 깊이 우선 탐색과 너비 우선탐색

25. http request에는 어떤 것들? 나열하고 설명

    - post, get, delete, put, patch 등등

26. http 요청과 응답 헤더에 어떤 내용이 들어가는가?

    - 공통 - http메시지가 만들어진 시각, 메시지 크기, 메시지 내용의 타입
    - 요청 - 서버의 도메인네임, 어떤 클라이언트를 통해 요청했는지, 보내주길 기대하는 데이터 타입, 인증 토큰, 요청이 시작된 주소, 
    - 응답 - Access-Control-Allow-Origin(서버가 허용하는 cors요청), content-security-policy(외부 파일 불러오는 경우 허용하는 소스)
    - cors 요청시엔 options로 미리 허용하는지 확인함

27. http와 https의 차이점?

    - http는 정보를 텍스트 그대로 통신하지만 s는 암호화해서 통신한다. 이때 ssl을 이용한다. 양쪽 다 키를 갖고 있어서 클라이언트가 갖고 있는 키를 이용해 암호화된 내용이 풀리면 서버에서 보낸 내용이라고 신뢰하고 사용.

28. url 축약서비스를 어떻게 설계할래?

    - response header에 location이라는 항목이 있는데 이 부분에 어떤 url이 오면 그 주소로 이동을 한다. bitly도 마찬가지로 원래의 url을 해쉬펑션으로 축약한후 db에 축약한 값에 원래의 주소를 붙여놓은후 브라우저에서 get요청이 오면 원래의 url을 location에 싣어 보내주어 이동하게 한다.

29. cors란 무엇인가, 목적과 활용

    - 처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청되는 경우 일어나는 요청, 예로 Adomain에 요청을 했는데 image 태그에 Cdomain이 있으면 cors요청이 일어남

30. 대표적인 서버 응답 코드에 대해 설명

    - 200번대 - 200 요청 정상처리, 204 요청 정상 처리지만 no content, 206 range가 지정된 요청인 경우, 지정된 범위만큼 요청 받음을 알려줌
    - 300번대 - 301 새로운 uri지정 이후로 새 uri나타냄, 302 301과 비슷하나 일시적인 이동, 304 요청한 리소스가 변경이 없음
    - 400번대 - 클라이언트에러, 400 클라이언트 요청구문이 잘못됨, 401 인증정보가 필요함을 알려줌 접근 허용을 차단함, 403 권한이 없음을 알려줌(401과 403의 차이는 401은 인증정보의 일시적인 문제, 403은 권한에 대한 문제), 404 클라이언트가 요청한 리소스가 서버에 없음, 405 허용되지 않는 메소드
    - 500번대 - 서버 에러, 500 요청 처리중에 에러발생, 503 과부화 또는 점검중, 504 서버를 통하는 게이트웨이에 문제가 생겨 시간이 초과, 505 해당 http버전에선 지원되지 않는 요청

31. arr

* 웹팩이란 - 모듈 여러개를 하나의 파일로 만드는 것. 모든 파일을 모듈로 관리한다.

32. 웹 서비스 프로토콜에는 어떤 것들이 있는가?

- SOAP: http, https, smtp를 통해 xml 메세지를 네트워크 상에서 교환하는 프로토콜
- WSDL: 웹 서비스 기술 언어 또는 기술된 정의 파일의 총칭, xml로 됨
- UDDI: 웹 서비스를 등록하고 검색하기 위한 저장소

33. Restful api란? 단점과 장점은?

- REST 정의: resource를 method로 구분하여 resource의 상태를 주고 받는 모든 것
- 장점: 메세지가 의도하는 바를 명확하게 나타내므로 하려고 하는 것을 쉽게 파악할 수 있다.
- 단점: 표준이 존재하지 않는다.
- 구형 브라우저가 지원하지 못하는 method가 존재

34. session-cookie와 token의 차이점

- session -cookie는 server and client side 에 정보를 저장하지만 token은 그 자체에 저장을 하는 방식이다.

35. database를 써야하는 이유

- file로 데이터를 저장하기에는 한계가 있어서 database를 쓴다.

36. sql vs nosql 

- sql은 data가 unchangeable, structured할 때 nosql은 빠르게 변하는 상황에서 사용

37. orm 사용의 단점과 장점

- 장점: 객체 지향적인 코드로 더 직관적이고 쿼리문을 사용하지 않고서도 쉽게 쓸 수 있다. 
- 코드가 급격히 준다.
- 단점: 복잡성이 높아지면 난이도가 올라간다. 잘못 구현하면 속도 저하가 크게 일어난다.

38. sql database를 짤 때 가장 중요하게 생각하는 부분은?

- rdbms이므로 관계가 가장 중요하다. 어떤 관계를 맺어야 나중에 db에서 data를 꺼내 쓸 때 효율적일지를 생각한다. 

39. database indexing이란 무엇이며 왜 하는가?

- 특정 테이블에 index를 주어 index 되어있는 파일을 검색하여 검색속도를 높이는 방법이다. 테이블에 데이터가 많을 때 검색 속도를 높이기 위해 사용한다.

40. transaction이란 무엇이며 언제 사용하는가

- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위(쿼리문 하나를 뜻 하는 것은 아니다. 쿼리문이 여러개 있어도 하나의 작업단위 안에 있을 수 있다. 예로 data를 update하고 update된 data를 가져올 때)(예출금을 예로 들 수 있다. 예금이 일어나지 않으면 출금도 일어나지 않게 하나의 단위로 묶는 것)
- db에 반영하는 것을 commit이라고 하고 반영하지 않고 원래 상태로 되돌리는 것을 roll-back이라고 한다.
- roll-back: database에 반영된 명령을 되돌리고 싶을 때 사용한다.
- 반영을 확정하는 것은 commit 하기전에는 반드시 start transaction

41. sql injection이란 무엇이며 어떻게 막을 수 있을까

- database에 쿼리문을 보내는 것 사이에 악의적인 의도를 가진 sql 쿼리문을 실행하는 기법. 주로 사용자가 입력한 데이터를 제대로 필터링, 이스케이핑 하지 못했을 경우 발생

- 크게 두가지의 방법으로 공격이 행해진다
- 첫번째로는 로그인 인증 쿼리문이 무조건 true의 결과값이 나오게 하여 인증을 무력화 시키는 방법이다. 이때는 특수문자 여부를 검사하여 방어할 수 있다.
- 두번째는 잘못된 쿼리를 날려 에러를 유발시켜 오류가 나타나면 그것을 가지고 db의 구조를 유추하는 방법이다. 
- 막을 수 있는 방법은 저장 프로시저(stored procedure) 라는 것을 만드는 방법이 있는데, 이것은 개발자가 쿼리의 형식을 미리 지정해서 형식에 맞는 쿼리만 실행하게 하는 방법이다.

42. 사용자의 비밀번호는 어떻게 저장하나요?

- hash function을 이용하여 db의 정보를 빼내어도 원래의 비밀번호가 무엇인지 알지 못하도록 저장해야 한다.

---------------데이터베이스 완료

43. v8을 설명해 보시오.

- v8은 크롬과 node.js 의 런타임이다. javascript 코드를 머신 코드로 컴파일 한다. 바이트 코드와 같은 중간 코드는 생산하지 않는다. 여러개의 thread를 사용한다. 메인쓰레드는 코드를 가져와서 컴파일하고 실행한다. 컴파일을 위한 별도의 쓰레드가 있어서 이 쓰레드가 코드를 최적화하는 동안 메인쓰레드는 쉬지않고 코드를 수행할 수 있다. 객체에 대한 메모리 할당을 처리한다. 더 이상 필요없는 객체를 가비지 수집한다.
- 힙은 메모리를 할당받는 구조화되지 않은 영역
- v8엔진은 크게 콜스택과 메모리 힙으로 나뉜다. 자바스크립트의 객체 할당은 동적이다.
- 우리가 만든 프로그램의 코드를 실행하라고 js엔진 보통 v8에게 명령하는 것은 호스팅 환경(node js 또는 웹브라우저 또는 각 로봇 스마트 전구와 같은 장치 )이다.
- 이러한 호스팅 환경이 공통적으로 갖고 있는 것이 이벤트 루프인데 이벤트 루프는 콜 스택이 비어있으면 콜백 큐에서 첫 번째 이벤트를 가져다가 밀어넣는 역할만 한다. 이러한 반복을 이벤트 루프에서는 틱 이라고 부른다.
- 호스팅 환경이 브라우저라면 비동기 적인 함수들을 기다리는 곳이 web APIs 이다. web APIs가 처리하는 것 중에는 DOM, Timeout, ajax가 있다.
- 프로미스는 외부의 시간으로부터 독립적이다. 충족 또는 거절을 기다리므로. 프로미스가 일단 충족되면 그 상태는 영원히 지속된다. 프로미스 값은 그 시점부터 불변(immutable)하는 상태가 되며 필요에 따라 몇 번이고 사용될 수 있다. 
- promise 를 사용하는 것보다 await/async를 사용하는 것이 훨씬 직관적이고 디버깅할 때도 promise는 어디서 에러가 일어난 것인지 확실히 알 수 없기 때문에 async가 유리하다. 참고로 async/await 은 ES8 구문.

44. 마이크로 서비스

- 모노리스의 반대되는 개념으로 크게 하나의 덩어리가 아닌 여러개의 작은 덩어리가 독립적으로 굴러가는 시스템. 하나의 큰앱이 아닌 여러개의 역할을 갖고 있는 앱으로 발전시킬 수도 있음. 유지보수가 쉬울 것 같다. 각 서비스마다 주기적인 배포를 목표로 함

45. localStorage, sessionStorage, cookie 차이 

- localStorage: 만료기한이 없고, 자바스크립트 또는 캐시를 통해 지워진다. 로컬리 데이터 세개중에 최대 한계가 제일 크다.
- sessionStorage: 브라우저가 종료될 때 까지만 저장되어 있다. 서버와 교류하지 않는다. 쿠키보단 한계가 크다.
- cookie: 다음 요청 때 서버로 되돌려보내진다. 서버사이트 또는 클라이언트 사이드에서 만료기한이 정해진다. 보통은 서버사이드. local과 session storage는 클라이언트에서만 읽지만 cookie는 서버에서도 읽는다. 쿠키는 처음부터 서버와 클라이언트 간의 지속적인 데이터 교환을 위해 만들어졌기 때문에 서버로 계속 전송이 된다. 이 때문에 용량을 계속 잡아먹어서 데이터 낭비가 발생할 수 있다.

46. html5란 

- 브라우저에서 동영상 음악 은행 업무 등을 하는데 단순히 html 문서 만으로 원활히 사용할 수 없었고 이 때문에 사용자에 pc에 추가 프로그램을 설치하는 방법이 등장했고, 이 추가 프로그램이 플러그인(plug-in) 이다. 플러그인중에 대표적인 것은 인터넷 익스플로러용 플러그인인 액티브엑스(ActiveX)이다.
- html5가 등장하면서 플러그인에 의존할 필요가 없어졌다.
- 즉 html5는 멀티미디어 다양한 애플리케이션까지 표현 제공하도록 진화한 웹 프로그래밍 언어이다.

47. xml과 html의 차이

- xml은 데이터 저장과 전송을 목적으로 만들어진 마크업 언어이다.
- html은 data를 웹상에 표현하기 위한 목적을 가진 마크업 언어.
- xml은 html과 달리 사전 정의 태그가 존재하지 않는다. 미리 정해진 태그가 없음.

48. 브라우저는 어떻게 동작하는가?

- 브라우저는 기본적으로 사용자 인터페이스 - 브라우저 엔진 - 렌더링엔진 ---통신, 자바스크립트해석기, UI백엔드 로 되어 있다.

- TCP/IP는 전송제어규약과 인터넷규약으로 데이터가 어떻게 웹을 건너 여행해야 하는지 정의하는 통신 규약이다. 이것은 차 또는 자전거와 같다.

- HTTP는 하이퍼텍스트 전송 규약으로 클라이언트와 서버가 통신할 수 있게 하기 위한 언어를 정의하는 규약이다. 상품을 주문하기 위해 우리가 사용하는 언어와 같다.

- 컴포넌트 파일: 한 웹 사이트는 다양한 종류의 상품과 같이 많은 파일로 만들어 진다. 이 파일들을 두개의 주요한 타입이 있다.

  - 코드 파일: html, css,js
  - 자원: 이미지, 음악, 비디오, 단어 문서, PDF

- 실제로 브라우저에 어떤일이 발생하는가

  1. 브라우저는 DNS 서버로 가서 웹사이트가 있는 서버의 진짜 주소를 찾습니다 (여러분이 상점의 주소를 찾습니다).

  2. 그 다음 브라우저는 서버에게 웹사이트의 사본을 클라이언트에게 보내달라는 HTTP 요청 메세지를 서버로 전송합니다.(상점으로 가서 상품을 주문합니다.) 이 메세지, 그리고 클라이언트와 서버 사이에 전송된 모든 데이터는 TCP/IP 연결을 통해서 전송됩니다. tcp는 stateful하다.

  3. 이 메세지를 받은 서버는 클라이언트의 요청을 승인하고, "200 OK" 메세지를 클라이언트에게 전송합니다. "200 OK"는 "물론이죠. 당신은 웹 사이트를 볼 수 있어요! 여기 있어요" 라는 의미입니다. 그 다음 서버는 웹사이트의 파일들을 데이터 패킷이라 불리는 작은 일련의 덩어리들로 브라우저에 전송하기 시작합니다.(상점은 여러분이 주문한 상품을 전달하고, 여러분은 그것을 집으로 가져갑니다.) 

  4. 브라우저는 이 작은 덩어리들을 완전한 웹 사이트로 조립하고, 당신에게 보여줍니다. (상품이 당신의 문에 도착합니다. — 새 것이죠, 멋져요!)

- 웹에서 서버에서 클라이언트로 데이터를 전송할 때 패킷이라는 수천개의 작은 덩어리로 전송한다. 이는 웹 사용자들이 동시에 같은 웹사이트를 볼 수 있게 하며 만약 한개의 덩어리로 전송된다면 한명의 사용자만 볼 수 있을 것이다.

- **정리하자면 dns로 웹브라우저 들어가면 tcp를 통해 http 통신 보내고 서버에서 보내주는 데이터 받아서 html과 css를 태그로 받고 그 태그를 토큰으로 바꾸고 토큰을 node로 바꾼 후 노드로 dom tree와 cssom을 만들어 attachment하여 화면에 띄워준다. dom tree와 cssom 이 만나면 render tree**

49. web socket이란?

- ​	WebSocket은 서버와 클라이언트 간에 socket connection을 유지해서 언제든 양방향 통신 또는 데이터 전송이 가능하도록 하는 기술이다. 대표적인 오픈소스로는 socket io가 있다.

50. client side rendering vs server side rendering ?

- CSR은 처음 로딩할 때 html 다운로드, javascript 다운로드 시간까지 모두 마쳐야 콘텐츠가 사용자에게 보여지기 때문에 초기 로딩 속도가 느리다. 그 이후엔 클라이언트에서 처리하므로 반응속도가 빠르다. CSR은 view를 생성하는데 javascript코드가 다 실행되어야 하기 때문에 웹 크롤러가 내용들을 읽을 수 없고 따라서 검색에 최적화 되어 있지 않다.
- SSR은 서버에서 view를 렌더링하여 가져오기 때문에 view를 보기까지 초기 구동속도가 빠르다. js파일을 전부 다운로드 받기 전까지는 제대로 동작하지 않지만 사용자는 빠르다 느낀다.

51. build란 무엇이며, 어떤 tool을 사용했는가

- 실행가능한 파일을 만든다. 소스코드를 실행가능하게 하나의 파일로 압축하는 것.
- create-react-app라는 boilerplate를 사용할 때 react-script build만 써봤다.

52. front-end 에서 신경써야 하는 보안은?

- 비밀번호를 암호화해서 보낸다던가, ssl을 적용하여 https를 사용하는 방법

53. common js 란 

- module.exports를 통해 모듈을 정의하고 require을 통해 정의한 모듈을 불러와 사용하자는 일종의 규약
- require함수는 module.exports를 리턴한다. exports도 module.exports를 가리킨다. exports는 단순히 module.exports를 참조한다. 그게 끝. 외워라.

54. CSRF란 무엇이며 막는 방법?

- 사용자의 의도와 상관없이 해킹하는 사람이 의도한 요청을 보내어 특정 웹페이지를 보안에 취약하게 하거나 정보를 수정 또는 삭제하는 공격방법
- 방어방법: 
  - request header에 있는 referrer 속성을 검증하여 차단, 같은 도메인 상에서 요청이 들어오지 않는다면 차단.
  - 민감한 정보를 수정 삭제 할 때에는 세션에 임의난수를 발급하여 해당 난수가 없는 상황에서 해당 동작들이 이루어지면 요청을 거부하는 방법.
  - 캡차 이미지상의 숫자/문자가 아니라면 요청을 거부하는 것.

55. xss란 무엇이며 막는 방법?

- 사용자 입력 값에 악의적인 스크립트를 넣어 스크립트를 동작하게 하는 공격
- server side에서 입력값에 대해 스크립트를 실행하려는 특수문자를 필터링한다.
- 또는 모든 특수문자를 일반 문자로 변환해서 server에서 처리하는 방법도 있다.

56. JSONP를 알고 있나요? 왜 필요하며 특징은 무엇인가요

- javascript는 sop 정책에 따라 다른 도메인간의 request를 제한한다. 그러나 script 태그는 sop에 속하지 않는다는 특성으로 다른 도메인간의 request를 위해 jsonp를 사용한다.
- json을 callback함수로 감싸서 처리한다. 일반 json을 보내면 정책으로 인해 제한되기 때문이다.

57. 리액트란 무엇인가요? 다른 JS 프레임워크와 어떤 특징, 차별점이 있나요?

- 자바스크립트 라이브러리, 기능보다는 유지보수에 신경씀, virtual dom, jsx, component가 특징이다.

57. react state and props에 대해 설명해 보세요

- props는 부모 컴포넌트에서 받아오는 값으로 변경할 수가 없고 state는 컴포넌트 내에서 선언하며 값을 변경할 수 있다.

57. react immutable 에 대해 설명해 보세요

- state에 대해 한번 선언하면 그 state의 값은 유지시키고 새로운 객체를 생성하여 불변함을 유지하면서 리렌더링 할 수 있게 하는 것.

57. 리액트에 있는 라이프사이클들을 이야기해보고, 각 라이프사이클은 어떤 용도로 유익할지 설명해 보세요

- render, componentDidMount, componentDidUpdate, componentWillUnmount, shouldComponentUpdate, getDerivedStateFromProps(props에 의해 state가 업데이트 되어야할 때 사용해야 한다.), getSnapshotBeforeUpdate(componentDidUpdate가 실행되기 전에 실행되는 함수이다)

57. react router 와 같은 client side routing에 대해 설명해 주세요

- routing: 다른 주소에 따라 다른 뷰를 보여주는 것
- 주소에 따라 다른 뷰를 보여주는데 이것을 server까지 가서 정보를 받아오는 것이 아닌 client side에서 다른 컴포넌트를 불러와서 화면에 띄워주는 것

57. What can you tell me about JSX?

- html과 유사하게 사용하는 javascript와 xml이 합쳐진 형태의 javascript extension

57. flux vs mvc ?

- mvc는 양방향 데이터 흐름(view와 model이 서로에 대해 영향을 줄 수 있다.), flux는 단방향 데이터 흐름(action - dispatcher- store-view 방향으로만흐름) 디버깅 할때에 어느 부분에서 버그가 일어나는 지를 쉽게 추적할 수 있다.

57. redux에 대해 설명해 보세요'

- state를 통합 관리하기 위한 라이브러리. 
- store의 state는 action을 통해서만 변경할 수 있다.
- reducer는 action과 이전 state를 입력받아서 새로운 state를 리턴하는 함수다.
- mapStateToProps와 mapDispatchToProps를 이용하여 store의 state와 action의 함수들을 사용할 수 있다.

57. lazy loading이란?

- 이미지와 같이 사이즈가 큰 데이터를 로딩할 때 사용자의 브라우저 화면에 나타나는 데이터만 로딩하고 사용자가 스크롤 화면이동을 하면서 데이터에 가까워지면 로딩하는 방식

57. SPA는 기존 웹사이트와 무엇이 다른가요?

- single page application 전통적인 웹 어플리케이션은 페이지가 여러개. 

- ## SPA 의 단점

  SPA 의 단점은, 앱의 규모가 커지면 자바스크립트 파일 사이즈가 너무 커진다는 것 입니다. 유저가 실제로 방문하지 않을수도 있는 페이지에 관련된 렌더링 관련 스크립트도 불러오기 때문이죠. 하지만 걱정하지마세요. 우리가 2장에서 배울 Code Splitting 을 사용한다면 라우트 별로 파일들을 나눠서 트래픽과 로딩속도를 개선 할 수 있습니다.

57. AJAX 기술에 대해 설명해 보세요

- 서버와 통신하기 위해 XMLHttpRequest 객체를 사용하는 것
- 새로고침하지 않아도 수행되는 비동기성! 포인트 fetch도 ajax의 일종

57. script tag의 위치와 위치에 따라 고려해야 하는 점은 무엇인가요

- script tag는 html문서상에서 body위에 또는 아래에 있을 수도 있는데 고려해야 하는 점은 body에 특정 tag를 가리켜야 하는 script는 반드시 그 아래에 있어야 한다는 점이다. 그렇지 않으면 script의 가리키는 대상이 존재하지 않아 원하는 결과가 나오질 않는다.

57. 이벤트 버블링이란 무엇인가요? 어떻게 막을 수 있나요?

- html상에서 하위 엘리먼트에 이벤트를 주었을 때 상위 엘리먼트에도 이벤트가 적용되는 특성.
- 막는법: stopPropagation API를 사용하면 막을 수 있다.

57. CSS보다 SCSS/SASS가 가지고 있는 장점은?

- CSS보다 심플한 표기법으로 CSS를 구조화하여 표현할 수 있다.
- 스킬 레벨이 다른 팀원들과의 작업 시 발생할 수 있는 구문의 수준 차이를 평준화할 수 있다.
- CSS에는 존재하지 않는 Mixin 등의 강력한 기능을 활용하여 CSS 유지보수 편의성을 큰 폭으로 향상시킬 수 있다.

57. id와 class selctor는 어떻게 다르게 쓰이나요?

- id는 특정한 1개의 엘리먼트를 지칭할 때 많이 쓰고 class는 여러개의 공통된 속성을 부여하고 싶을 때 많이 쓰인다. 

57. css box model에 대해 말해보세요

- 웹의 레이아웃의 하나의 틀로, 엘리먼트는 직사각형 상자로 표시되며 상자의 내용, 테두리, 여백이 양파처럼 쌓인다.디폴트는 content-box의 width와 height가 width와 height값

57. css 에서 em, px, rem 의 차이점에 대해 이야기해 보세요

- em: 상위 엘리먼트 크기의 몇배로 할것인지
- rem: html 엘리먼트의 몇 배로 할 것인지
- px: 절대값

57. BMP, JPG, PNG 각각의 특징에 대해서 설명하라.

- png: 비손실 그래픽 파일 포맷, 빠른 출력 속도, 손실이 없다. jpeg보단 파일이 크다.
- jpeg: 손실 압축 방법 표준, 질과 파일의 크기를 조절할 수 있다. 고화질 압축률이 높아 용량이 작다, 손글씨 도트 아이콘등 이미지는 화질이 저하
- BMP: 운영체제에서 쓰이는 확장자로서 화질이 제일 선명, 압축이 되지 않아서 용량 매우 높음, 대부분의 사이트에서 업로드를 제한해 인터넷에 올리기 어려움 

57. 웹페이지 Redirect의 다양한 구현법에 대해서 설명하라.

- meta태그를 이용해 url 속성에 이동하려는 url을 넣어주기
- javascript의 location.href 로 url 값 넣어주기

57. Unicode와 UTF-8에 대해서 설명하라

- 전세계 언어를 모두 표시할 수 있는 표준코드 - 글자와 코드가 1:1 매핑되어 있는 코드표
- utf-8은 유니코드를 인코딩하는 방식 중 하나로 유니코드 한 문자를 나타내기 위해 1바이트에서 4바이트까지 사용한다.

57. Map/Reduce에 대해서 설명하라

- map 은 값이 다른 같은 크기의 array 를 만들고 싶을 때 사용하는 메소드
- reduce는 하나의 값으로 수렴하게 하고 싶을 때 사용하는 메소드

57. CSS의 다양한 Selector들에 대해서 설명하라

- \* : 모든 엘리먼트 자식도 가능함
- \# : id
- . : class
- descendant : ex) li a 
- type: ex) a
- :link : 클릭하기전
- :visited : 클릭한
- x+ y: x가 앞에 있는 y들만 선택
- x > y : 직계자식만 선택
- x ~ y : x 뒤에 나오는 모든 y
- x[attribute] : attribute를 갖고 있는 x (attribute뒤에 =도 가능)
- x[href^="http"] : http가 처음에 들어가는 물론 $도 가능

57. Multi-Column Index에 대해서 설명하라

- 두개의 컬럼을 하나의 인덱스로 사용을 하는 방법, 예를 들어 name이 유건이고 address가 서울인 값을 찾으려면 idx_index(name,address) 처럼 유건서울로 찾을 것이므로 더 빨리 찾을 수 있을 것이다. 하지만 서울로만 찾으려면 다중 컬럼인덱스로는 찾을 수 없다.

57. 비대칭키를 사용한 암호화에 대해서 설명하라

- 암호화하는 키와 복호화하는 키가 다른 암호화 방식으로 암호화하는 키는 보통 공개되므로 공개 키 라고한다. 그리고 복호화할 수 있는 키는 보통 개인 키라고 하는데 개인 키는 절대 유출되선 안된다.

57. Callback Hell을 피할 수 있는 방법에 대해서 설명하라

- promise 또는 async/await 을 쓰면 피할 수 있다.

57. Reflow가 발생하는 이유와 방지 방법에 대해서 설명하라.

- 모든 엘리먼트의 위치와 길이 등을 다시 계산하는 것으로 문서의 일부 혹은 전체를 다시 렌더링한다. 
- DOM 엘리먼트, CSS 추가 또는 변경, offsetWidth와 offsetHeight의 사용
- 방지법: 
  - 클래스 변경을 통해 스타일 변경할 경우 최대한 말단 노드의 클래스변경
  - 인라인 스타일 사용 ㄴㄴ
  - 애니메이션이 들어간 엘리먼트는 position을 fixed 또는 absolute로 지정한다.
  - 부드러운 애니메이션은 성능을 저하시킨다.
  - 레이아웃을 위한 table 태그는 피한다.
  - css에서 javascript 표현식을 사용하지 않는다.
  - css하위 셀렉터를 최소화한다.
  - style보단 class를 변경하라 style이 변경될때마다 reflow가 발생한다.

58. 오픈소스 라이브러리를 선택할 때 고려하는 점

- 업데이트가 계속 되고 있는지
- 증명되고 안전한 기술인지
- 버전이 1.0이상인지
- 레퍼런스가 충분한지





피드백

코드스테이츠에 대한 설명을 좀 더 매력적이게(아예 종이를 가져가는 것도 괜찮)

핵심을 얘기해라 ( 장황한 얘기는 줄여라 중간중간 의사를 물어보는 것도 좋다 )

기술적인 부분이 준비가 더 필요하다. 

내가 배운 것 중에 어떤 것이 좋았는지 실제 사례를 적용해서 얘기를 하자 (경험경험)

회사에 대한 리서치를 해라

실제로 회사마다 분위기가 다 다르다.



안녕하세요. 저는 유건입니다. 저는 집단 지성의 힘은 개인 지성보다 크다고 생각합니다. 그래서  팀으로 일하는 것이 개인으로 일하는 것보다 생산성이 높다고 생각합니다. 이러한 이유로 사람들과 함께 일하는 것을 더 좋아합니다. 또 한가지에 몰두하면 열정적으로 불태우는 사람입니다. 현재는 그 대상이 개발이고 무엇보다도 개발에 몰두하고 있는 개발자 입니다.



es6: template literal, destructuring, spread operator, rest parameter, export/import, promise, class, block scope, arrow function, 



- 오픈놀 기술면접 모르는 내용
  - iterable 의미와 iterator - iterable은 object가 반복될 수 있는지, iterator는 반복 가능한 object가 순서대로 열거될 수 있는지 **이 두 조건이 만족되면 그 object는 iteration을 수행할 수 있다.**
  - side effect, 순수함수란 ? - 순수함수는 내부적인 계산만하고 프로그램 실행에 side effect를 미치지 않는 것, side effect는 함수가 실행될 때 부수적으로 일어나는 영향
  - 일급함수 일급객체
    - 일급이란 1. 함수의 인자가 될 수 있고 2. 함수의 리턴이 될 수 있고, 변수에 할당 될 수 있는 자격을 가리키는데 이를 다 만족하는 객체를 일급객체, 함수는 일급함수라 한다.
  - react에서 웹사이트 성능을 높일 수 있는 방법 - code splitting : webpack의 기능 중 하나로, 여러개의 번들로 쪼갠 후 리소스의 우선 순위를 제어해 로드 시간에 영향을 준다.
  - redux middleware 사용경험 : 이 미들웨어는 action이 reducer로 가기 전에 중간 처리 작업을 해준다. 물론 redux-logger도 있음
    - saga - 
    - thunk - 비동기 작업을 처리 할 때 사용한다. 